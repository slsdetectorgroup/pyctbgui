#!/usr/bin/env python3
import time
from PyQt5 import QtWidgets, QtCore, QtGui, uic
import sys, os
import pyqtgraph as pg
from pyqtgraph import PlotWidget, GraphicsLayoutWidget
import multiprocessing as mp
from threading import Thread
from PIL import Image as im

import json
import zmq
import numpy as np
import posixpath
from pathlib import Path

from functools import partial
from slsdet import Detector, dacIndex, readoutMode, runStatus

from TabClasses.ADC import ADC
from TabClasses.Pattern import Pattern
from TabClasses.Transceiver import Transceiver
from TabClasses.DACs import DACs
from TabClasses.PowerSupplies import PowerSupplies
from TabClasses.Signals import Signals
from TabClasses.SlowADCs import SlowADCs
from bit_utils import set_bit, remove_bit, bit_is_set, manipulate_bit
import random

from defines import *
from plotPattern import PlotPattern
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

import argparse
import alias_utility 
import signal

import decoder
from pixelmap import moench04_analog, matterhorn_transceiver

class MainWindow(QtWidgets.QMainWindow):
    signalShortcutAcquire = QtCore.pyqtSignal()
    signalShortcutTabUp = QtCore.pyqtSignal()
    signalShortcutTabDown = QtCore.pyqtSignal()

    def __init__(self, *args, **kwargs):
        parser = argparse.ArgumentParser()
        parser.add_argument('-a', '--alias', help = "Alias file complete path")
        arglist = parser.parse_args()
        self.alias_file = arglist.alias

        pg.setConfigOption("background", (247, 247, 247))
        pg.setConfigOption("foreground", "k")
        pg.setConfigOption('leftButtonPan', False)
        
        super(MainWindow, self).__init__()
        uic.loadUi("CtbGui.ui", self)

        self.updateSettingValues()
        
        self.det = None
        try:
            self.det = Detector()
            # ensure detector is up
            self.det.detectorserverversion[0]
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Connect Fail", str(e) + "Exiting Gui...",  QtWidgets.QMessageBox.Ok)
            raise

        # get Tab Classes
        self.slowADCsTab = SlowADCs(self)
        self.dacTab = DACs(self)
        self.powerSuppliesTab = PowerSupplies(self)
        self.signalTab = Signals(self)
        self.transceiverTab = Transceiver(self)
        self.adcTab = ADC(self)
        self.patternTab = Pattern(self)

        self.setup_zmq()
        self.setup_ui()
        self.tabWidget.setCurrentIndex(Defines.Acquisition_Tab_Index)
        self.tabWidget.currentChanged.connect(self.refresh_tab)
        self.connect_ui()

        self.dacTab.refresh()
        self.powerSuppliesTab.refresh()
        self.slowADCsTab.refresh()
        self.signalTab.refresh()
        self.transceiverTab.refresh()
        self.adcTab.refresh()
        self.patternTab.refresh()
        self.refresh_tab_acquisition()
        self.refresh_tab_plot()

        # also refreshes timer to start plotting 
        self.plotOptions()
        self.showPlot()

        self.patternTab.getPatViewerColors()
        self.patternTab.getPatViewerWaitParameters()
        self.patternTab.getPatViewerLoopParameters()
        self.patternTab.updatePatViewerParameters()
        self.showPatternViewer(False)

        if self.alias_file is not None:
            self.loadAliasFile()

        self.signalShortcutAcquire.connect(self.pushButtonStart.click)
        self.signalShortcutTabUp.connect(partial(self.changeTabIndex, True))
        self.signalShortcutTabDown.connect(partial(self.changeTabIndex, False))
        # to catch the ctrl + c to abort
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        self.firstAnalogImage = True
        self.firstDigitalImage = True
        self.firstTransceiverImage = True

    def updateSettingMainWindow(self):
        self.settings.beginGroup("mainwindow");
        # window size
        width = self.settings.value('window_width')
        height = self.settings.value('window_height')
        if width is not None and height is not None:
            self.resize(int(width), int(height))
            #print(f'Main window resized to {width}x{height}')

        # window position
        pos = self.settings.value('window_pos')
        if type(pos) is QtCore.QPoint:
            #print(f'Moved main window to {pos}')
            self.move(pos)
        self.settings.endGroup();

    def saveSettingMainWindow(self):
        self.settings.beginGroup("mainwindow");
        self.settings.setValue('window_width', self.rect().width())
        self.settings.setValue('window_height', self.rect().height())
        self.settings.setValue('window_pos', self.pos())
        self.settings.endGroup();

    def updateSettingDockWidget(self):
        self.settings.beginGroup("dockwidget");

        # is docked
        if self.settings.contains('window_width') and self.settings.contains('window_height'): 
            # window size
            width = self.settings.value('window_width')
            height = self.settings.value('window_height')
            if width is not None and height is not None:
                #print(f'Plot window - Floating ({width}x{height})')
                self.dockWidget.setFloating(True)
                self.dockWidget.resize(int(width), int(height))
            # window position
            pos = self.settings.value('window_pos')
            if type(pos) is QtCore.QPoint:
                #print(f'Moved plot window to {pos}')
                self.dockWidget.move(pos)
        self.settings.endGroup();

    def saveSettingDockWidget(self):
        self.settings.beginGroup("dockwidget");
        if self.dockWidget.isFloating():
            self.settings.setValue('window_width', self.dockWidget.rect().width())
            self.settings.setValue('window_height', self.dockWidget.rect().height())
            self.settings.setValue('window_pos', self.dockWidget.pos())
        else:
            self.settings.remove('window_width')
            self.settings.remove('window_height')
            self.settings.remove('window_pos')
        self.settings.endGroup();

    def updateSettingValues(self):
        self.settings = QtCore.QSettings('slsdetectorgroup', 'pyctbgui')
        self.updateSettingMainWindow()
        self.updateSettingDockWidget()

    def saveSettings(self):
        # store in ~/.config/slsdetectorgroup/pyctbgui.conf
        self.saveSettingMainWindow()
        self.saveSettingDockWidget()         

    def closeEvent(self, event):
        self.saveSettings()

    def loadAliasFile(self):
        print(f'Loading Alias file: {self.alias_file}')
        try:
            bit_names, bit_plots, bit_colors, adc_names, adc_plots, adc_colors, dac_names, slowadc_names, voltage_names, pat_file_name = alias_utility.read_alias_file(self.alias_file)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Alias File Fail", str(e) + "<br> " + self.alias_file, QtWidgets.QMessageBox.Ok)
            return

        for i in range(64):
            if bit_names[i]:
                self.det.setSignalName(i, bit_names[i])
            if bit_plots[i]:
                getattr(self, f"checkBoxBIT{i}DB").setChecked(bit_plots[i])
                getattr(self, f"checkBoxBIT{i}Plot").setChecked(bit_plots[i])
            if bit_colors[i]:
                self.signalTab.setDBitButtonColor(i, bit_colors[i])

        for i in range(32):
            if adc_names[i]:
                self.det.setAdcName(i, adc_names[i])
            if adc_plots[i]:
                getattr(self, f"checkBoxADC{i}En").setChecked(adc_plots[i])
                getattr(self, f"checkBoxADC{i}Plot").setChecked(adc_plots[i])
            if adc_colors[i]:
                self.adcTab.setADCButtonColor(i, adc_colors[i])

        for i in range(18):
            if dac_names[i]:
                iDac = getattr(dacIndex, f"DAC_{i}")
                self.det.setDacName(iDac, dac_names[i])

        for i in range(8):
            if slowadc_names[i]:
                self.det.setSlowAdcName(i, slowadc_names[i])

        for i in range(5):
            if voltage_names[i]:
                self.det.setVoltageName(i, voltage_names[i])

        if pat_file_name:
            self.lineEditPatternFile.setText(pat_file_name)

        self.signalTab.updateSignalNames()
        self.adcTab.updateADCNames()
        self.slowADCsTab.updateSlowAdcNames()
        self.dacTab.updateDACNames()
        self.powerSuppliesTab.updateVoltageNames()
        

    # For Action options function
    # TODO Only add the components of action option+ functions
    # Function to show info
    def showInfo(self):
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle("About")
        msg.setText("This Gui is for Chip Test Boards.\n Current Phase: Development")
        x = msg.exec_()

    def showKeyBoardShortcuts(self):
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle("Keyboard Shortcuts")
        msg.setText("Start Acquisition (from any tab): Shift + Return<br>Move Tab Right : Ctrl + '+'<br>Move Tab Left : Ctrl + '-'<br>")
        x = msg.exec_()

    def loadParameters(self):
        response = QtWidgets.QFileDialog.getOpenFileName(
            parent=self,
            caption="Select a parameter file to open",
            directory=os.getcwd(),
            # filter='README (*.md *.ui)'
        )
        if response[0]:
            try:
                parameters = response[0]
                QtWidgets.QMessageBox.information(self, "Load Parameter Success", "Parameters loaded successfully", QtWidgets.QMessageBox.Ok)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Load Parameter Fail", str(e), QtWidgets.QMessageBox.Ok)
                pass


        

    # Plot Tab functions
    
    def initializeColorMaps(self):
        self.comboBoxColorMap.addItems(Defines.Color_map)
        self.comboBoxColorMap.setCurrentIndex(Defines.Color_map.index(Defines.Default_Color_Map))
        self.setColorMap()

    def setColorMap(self):
        cm = pg.colormap.getFromMatplotlib(self.comboBoxColorMap.currentText())
        # print(f'color map:{self.comboBoxColorMap.currentText()}')
        self.plotAnalogImage.setColorMap(cm)
        self.plotDigitalImage.setColorMap(cm)
        self.plotTransceiverImage.setColorMap(cm)

    def getZMQHWM(self):

        self.comboBoxZMQHWM.currentIndexChanged.disconnect()

        rx_zmq_hwm = self.det.getRxZmqHwm()[0]
        # ensure same value in client zmq
        self.det.setClientZmqHwm(rx_zmq_hwm)

        # high readout, low HWM
        if rx_zmq_hwm < 25 and rx_zmq_hwm > -1:
            self.comboBoxZMQHWM.setCurrentIndex(1)
        # low readout, high HWM
        else:
            self.comboBoxZMQHWM.setCurrentIndex(0)
        self.comboBoxZMQHWM.currentIndexChanged.connect(self.setZMQHWM)


    def setZMQHWM(self):
        val = self.comboBoxZMQHWM.currentIndex()
        # low readout, high HWM
        if val == 0:
            self.det.setRxZmqHwm(Defines.Zmq_hwm_low_speed)
            self.det.setClientZmqHwm(Defines.Zmq_hwm_low_speed)
        # high readout, low HWM
        else:
            self.det.setRxZmqHwm(Defines.Zmq_hwm_high_speed)
            self.det.setClientZmqHwm(Defines.Zmq_hwm_high_speed)

        self.getZMQHWM()

    def initializeAllAnalogPlots(self):

        self.plotAnalogWaveform = pg.plot()
        self.verticalLayoutPlot.addWidget(self.plotAnalogWaveform, 1)
        self.analogPlots = {}
        waveform = np.zeros(1000)
        for i in range(32):
            pen = pg.mkPen(color = self.adcTab.getADCButtonColor(i), width = 1)
            legendName = getattr(self, f"labelADC{i}").text()
            self.analogPlots[i] = self.plotAnalogWaveform.plot(waveform, pen=pen, name = legendName)
            self.analogPlots[i].hide()

        self.plotAnalogImage = pg.ImageView()
        self.nAnalogRows = 0
        self.nAnalogCols = 0
        self.analog_frame = np.zeros((self.nAnalogRows, self.nAnalogCols))
        self.plotAnalogImage.getView().invertY(False)
        self.plotAnalogImage.setImage(self.analog_frame)
        self.verticalLayoutPlot.addWidget(self.plotAnalogImage, 2)

    def addSelectedAnalogPlots(self, i):
            enable = getattr(self, f"checkBoxADC{i}Plot").isChecked()
            if enable:
                self.analogPlots[i].show()
            if not enable:
                self.analogPlots[i].hide()

    def addAllSelectedAnalogPlots(self):
        for i in range(32):
            self.addSelectedAnalogPlots(i)

    def removeAllAnalogPlots(self):
        for i in range(32):
            self.analogPlots[i].hide()

    def initializeAllDigitalPlots(self):
        self.plotDigitalWaveform = pg.plot()
        self.verticalLayoutPlot.addWidget(self.plotDigitalWaveform, 3)
        self.digitalPlots = {}
        waveform = np.zeros(1000)
        for i in range(64):
            pen = pg.mkPen(color = self.signalTab.getDBitButtonColor(i), width = 1)
            legendName = getattr(self, f"labelBIT{i}").text()
            self.digitalPlots[i] = self.plotDigitalWaveform.plot(waveform, pen=pen, name = legendName, stepMode = "left")
            self.digitalPlots[i].hide()

        self.plotDigitalImage = pg.ImageView()
        self.nDigitalRows = 0
        self.nDigitalCols = 0
        self.digital_frame = np.zeros((self.nDigitalRows, self.nDigitalCols))
        self.plotDigitalImage.setImage(self.digital_frame)
        self.verticalLayoutPlot.addWidget(self.plotDigitalImage, 4)

        cm = pg.colormap.get('CET-L9') # prepare a linear color map
        self.plotDigitalImage.setColorMap(cm)

    def addSelectedDigitalPlots(self, i):
            enable = getattr(self, f"checkBoxBIT{i}Plot").isChecked()
            if enable:
                self.digitalPlots[i].show()
            if not enable:
                self.digitalPlots[i].hide()

    def addAllSelectedDigitalPlots(self):
        for i in range(64):
            self.addSelectedDigitalPlots(i)

    def removeAllDigitalPlots(self):
        for i in range(64):
            self.digitalPlots[i].hide()

    def initializeAllTransceiverPlots(self):
        self.plotTransceiverWaveform = pg.plot()
        self.verticalLayoutPlot.addWidget(self.plotTransceiverWaveform, 5)
        self.transceiverPlots = {}
        waveform = np.zeros(1000)
        for i in range(4):
            pen = pg.mkPen(color = self.transceiverTab.getTransceiverButtonColor(i), width = 1)
            legendName = getattr(self, f"labelTransceiver{i}").text()
            self.transceiverPlots[i] = self.plotTransceiverWaveform.plot(waveform, pen=pen, name = legendName)
            self.transceiverPlots[i].hide()

        self.plotTransceiverImage = pg.ImageView()
        self.nTransceiverRows = 0
        self.nTransceiverCols = 0
        self.transceiver_frame = np.zeros((self.nTransceiverRows, self.nTransceiverCols))
        self.plotTransceiverImage.setImage(self.transceiver_frame)
        self.verticalLayoutPlot.addWidget(self.plotTransceiverImage, 6)

        cm = pg.colormap.get('CET-L9') # prepare a linear color map
        self.plotTransceiverImage.setColorMap(cm)

    def addSelectedTransceiverPlots(self, i):
            enable = getattr(self, f"checkBoxTransceiver{i}Plot").isChecked()
            if enable:
                self.transceiverPlots[i].show()
            if not enable:
                self.transceiverPlots[i].hide()

    def addAllSelectedTransceiverPlots(self):
        for i in range(4):
            self.addSelectedTransceiverPlots(i)

    def removeAllTransceiverPlots(self):
        for i in range(4):
            self.transceiverPlots[i].hide()

    def showPlot(self):
        self.plotAnalogWaveform.hide()
        self.plotDigitalWaveform.hide()
        self.plotTransceiverWaveform.hide()
        self.plotAnalogImage.hide()
        self.plotDigitalImage.hide()
        self.plotTransceiverImage.hide()
        self.labelDigitalWaveformOption.setDisabled(True)
        self.radioButtonOverlay.setDisabled(True)
        self.radioButtonStripe.setDisabled(True)

        if self.romode.value in [0, 2]:
            if self.radioButtonWaveform.isChecked():
                self.plotAnalogWaveform.show()
            elif self.radioButtonImage.isChecked():
                self.plotAnalogImage.show()
        if self.romode.value in [1, 2, 4]:
            if self.radioButtonWaveform.isChecked():
                self.plotDigitalWaveform.show()
            elif self.radioButtonImage.isChecked():
                self.plotDigitalImage.show()
            self.labelDigitalWaveformOption.setEnabled(True)
            self.radioButtonOverlay.setEnabled(True)
            self.radioButtonStripe.setEnabled(True)

        if self.romode.value in [3, 4]:
            if self.radioButtonWaveform.isChecked():
                self.plotTransceiverWaveform.show()
            elif self.radioButtonImage.isChecked():
                self.plotTransceiverImage.show()

    def plotOptions(self):

        self.framePatternViewer.hide()
        self.showPlot()

        # disable plotting
        self.read_timer.stop()
        
        if self.radioButtonWaveform.isChecked():
            self.plotAnalogWaveform.setLabel('left',"<span style=\"color:black;font-size:14px\">Output [ADC]</span>")
            self.plotAnalogWaveform.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Analog Sample [#]</span>")
            self.plotAnalogWaveform.addLegend(colCount = 4)
            self.plotDigitalWaveform.setLabel('left',"<span style=\"color:black;font-size:14px\">Digital Bit</span>")
            self.plotDigitalWaveform.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Digital Sample [#]</span>")
            self.plotDigitalWaveform.addLegend(colCount = 4)
            self.plotTransceiverWaveform.setLabel('left',"<span style=\"color:black;font-size:14px\">Transceiver Bit</span>")
            self.plotTransceiverWaveform.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Transceiver Sample [#]</span>")
            self.plotTransceiverWaveform.addLegend(colCount = 4)

            self.stackedWidgetPlotType.setCurrentIndex(0)

        elif self.radioButtonImage.isChecked():
            self.stackedWidgetPlotType.setCurrentIndex(2)
            self.setPixelMap()
                
        if self.radioButtonNoPlot.isChecked():
            self.labelPlotOptions.hide()
            self.stackedWidgetPlotType.hide()
        # enable plotting
        else:
            self.labelPlotOptions.show()
            self.stackedWidgetPlotType.show()
            self.read_timer.start(Defines.Time_Plot_Refresh_ms)
        
    def setPixelMap(self):
        if self.comboBoxPlot.currentText() == "Matterhorn":
            self.nTransceiverRows = Defines.Matterhorn.nRows		
            self.nTransceiverCols = Defines.Matterhorn.nCols
            self.pixelMapTransceiver = matterhorn_transceiver()
        elif self.comboBoxPlot.currentText() == "Moench04":
            self.nAnalogRows = Defines.Moench04.nRows
            self.nAnalogCols = Defines.Moench04.nCols
            self.pixelMapAnalog = moench04_analog()

    def showPatternViewer(self, enable):
        if enable:
            self.framePatternViewer.show()
            self.framePlot.hide()
        elif self.framePatternViewer.isVisible():
                self.framePatternViewer.hide()
                self.framePlot.show()
                self.showPlot()


    def setSerialOffset(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setNCounter(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setDynamicRange(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setImageX(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setImageY(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setPedestal(self):
        print("plot options - Not implemented yet")
        #TODO: acquire, subtract, common mode
        
    def resetPedestal(self):
        print("plot options - Not implemented yet")
        #TODO:

    def setRawData(self):
        print("plot options - Not implemented yet")
        #TODO: raw data, min, max
        
    def setPedestalSubtract(self):
        print("plot options - Not implemented yet")
        #TODO: pedestal, min, max

    def setFitADC(self):
        print("plot options - Not implemented yet")
        #TODO:
        
    def setPlotBit(self):
        print("plot options - Not implemented yet")
        #TODO:

    def plotReferesh(self):
        self.read_zmq()
        

    # Acquisition Tab functions

    def getReadout(self):
        self.comboBoxROMode.currentIndexChanged.disconnect()
        self.spinBoxAnalog.editingFinished.disconnect()
        self.spinBoxDigital.editingFinished.disconnect()
        self.spinBoxTransceiver.editingFinished.disconnect()

        self.romode = self.det.romode
        self.comboBoxROMode.setCurrentIndex(self.romode.value)
        match self.romode:
            case readoutMode.ANALOG_ONLY:
                self.spinBoxAnalog.setEnabled(True)
                self.labelAnalog.setEnabled(True)
                self.spinBoxDigital.setDisabled(True)
                self.labelDigital.setDisabled(True)
                self.labelTransceiver.setDisabled(True)
                self.spinBoxTransceiver.setDisabled(True)
            case readoutMode.DIGITAL_ONLY:
                self.spinBoxAnalog.setDisabled(True)
                self.labelAnalog.setDisabled(True)
                self.spinBoxDigital.setEnabled(True)
                self.labelDigital.setEnabled(True)
                self.labelTransceiver.setDisabled(True)
                self.spinBoxTransceiver.setDisabled(True)
            case readoutMode.ANALOG_AND_DIGITAL:
                self.spinBoxAnalog.setEnabled(True)
                self.labelAnalog.setEnabled(True)
                self.spinBoxDigital.setEnabled(True)
                self.labelDigital.setEnabled(True)
                self.labelTransceiver.setDisabled(True)
                self.spinBoxTransceiver.setDisabled(True)
            case readoutMode.TRANSCEIVER_ONLY:
                self.spinBoxAnalog.setDisabled(True)
                self.labelAnalog.setDisabled(True)
                self.spinBoxDigital.setDisabled(True)
                self.labelDigital.setDisabled(True)
                self.labelTransceiver.setEnabled(True)
                self.spinBoxTransceiver.setEnabled(True)
            case _:
                self.spinBoxAnalog.setDisabled(True)
                self.labelAnalog.setDisabled(True)
                self.spinBoxDigital.setEnabled(True)
                self.labelDigital.setEnabled(True)
                self.labelTransceiver.setEnabled(True)
                self.spinBoxTransceiver.setEnabled(True)

        self.comboBoxROMode.currentIndexChanged.connect(self.setReadOut)
        self.spinBoxAnalog.editingFinished.connect(self.setAnalog)
        self.spinBoxDigital.editingFinished.connect(self.setDigital)
        self.spinBoxTransceiver.editingFinished.connect(self.setTransceiver)
        self.getAnalog()
        self.getDigital()
        self.showPlot()

    def setReadOut(self):
        self.comboBoxROMode.currentIndexChanged.disconnect()
        try:
            if self.comboBoxROMode.currentIndex() == 0:
                self.det.romode = readoutMode.ANALOG_ONLY
            elif self.comboBoxROMode.currentIndex() == 1:
                self.det.romode = readoutMode.DIGITAL_ONLY
            elif self.comboBoxROMode.currentIndex() == 2:
                self.det.romode = readoutMode.ANALOG_AND_DIGITAL
            elif self.comboBoxROMode.currentIndex() == 3:
                self.det.romode = readoutMode.TRANSCEIVER_ONLY
            else:
                self.det.romode = readoutMode.DIGITAL_AND_TRANSCEIVER
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Readout Mode Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.comboBoxROMode.currentIndexChanged.connect(self.setReadOut)
        self.getReadout()

    def getRunFrequency(self):
        self.spinBoxRunF.editingFinished.disconnect()
        self.spinBoxRunF.setValue(self.det.runclk)
        self.spinBoxRunF.editingFinished.connect(self.setRunFrequency)

    def setRunFrequency(self):
        self.spinBoxRunF.editingFinished.disconnect()
        try:
            self.det.runclk = self.spinBoxRunF.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Run Frequency Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxRunF.editingFinished.connect(self.setRunFrequency)
        self.getRunFrequency()

    def getTransceiver(self):
        self.spinBoxTransceiver.editingFinished.disconnect()
        self.tsamples = self.det.tsamples
        self.spinBoxTransceiver.setValue(self.tsamples)
        self.spinBoxTransceiver.editingFinished.connect(self.setTransceiver)

    def setTransceiver(self):
        self.spinBoxTransceiver.editingFinished.disconnect()
        try:
            self.det.tsamples = self.spinBoxTransceiver.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Transceiver Samples Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxTransceiver.editingFinished.connect(self.setTransceiver)
        self.getTransceiver()

    def getAnalog(self):
        self.spinBoxAnalog.editingFinished.disconnect()
        self.asamples = self.det.asamples
        self.spinBoxAnalog.setValue(self.asamples)
        self.spinBoxAnalog.editingFinished.connect(self.setAnalog)

    def setAnalog(self):
        self.spinBoxAnalog.editingFinished.disconnect()
        try:
            self.det.asamples = self.spinBoxAnalog.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Digital Samples Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxAnalog.editingFinished.connect(self.setAnalog)
        self.getAnalog()

    def getDigital(self):
        self.spinBoxDigital.editingFinished.disconnect()
        self.dsamples = self.det.dsamples
        self.spinBoxDigital.setValue(self.dsamples)
        self.spinBoxDigital.editingFinished.connect(self.setDigital)

    def setDigital(self):
        self.spinBoxDigital.editingFinished.disconnect()
        try:
            self.det.dsamples = self.spinBoxDigital.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Digital Samples Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxDigital.editingFinished.connect(self.setDigital)
        self.getDigital()

    def getADCFrequency(self):
        self.spinBoxADCF.editingFinished.disconnect()
        self.spinBoxADCF.setValue(self.det.adcclk)
        self.spinBoxADCF.editingFinished.connect(self.setADCFrequency)

    def setADCFrequency(self):
        self.spinBoxADCF.editingFinished.disconnect()
        try:
            self.det.adcclk = self.spinBoxADCF.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "ADC Frequency Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxADCF.editingFinished.connect(self.setADCFrequency)
        self.getADCFrequency()

    def getADCPhase(self):
        self.spinBoxADCPhase.editingFinished.disconnect()
        self.spinBoxADCPhase.setValue(self.det.adcphase)
        self.spinBoxADCPhase.editingFinished.connect(self.setADCPhase)

    def setADCPhase(self):
        self.spinBoxADCPhase.editingFinished.disconnect()
        try:
            self.det.adcphase = self.spinBoxADCPhase.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "ADC Phase Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxADCPhase.editingFinished.connect(self.setADCPhase)
        self.getADCPhase()

    def getADCPipeline(self):
        self.spinBoxADCPipeline.editingFinished.disconnect()
        self.spinBoxADCPipeline.setValue(self.det.adcpipeline)
        self.spinBoxADCPipeline.editingFinished.connect(self.setADCPipeline)

    def setADCPipeline(self):
        self.spinBoxADCPipeline.editingFinished.disconnect()
        try:
            self.det.adcpipeline = self.spinBoxADCPipeline.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "ADC Pipeline Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxADCPipeline.editingFinished.connect(self.setADCPipeline)
        self.getADCPipeline()

    def getDBITFrequency(self):
        self.spinBoxDBITF.editingFinished.disconnect()
        self.spinBoxDBITF.setValue(self.det.dbitclk)
        self.spinBoxDBITF.editingFinished.connect(self.setDBITFrequency)

    def setDBITFrequency(self):
        self.spinBoxDBITF.editingFinished.disconnect()
        try:
            self.det.dbitclk = self.spinBoxDBITF.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "DBit Frequency Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxDBITF.editingFinished.connect(self.setDBITFrequency)
        self.getDBITFrequency()

    def getDBITPhase(self):
        self.spinBoxDBITPhase.editingFinished.disconnect()
        self.spinBoxDBITPhase.setValue(self.det.dbitphase)
        self.spinBoxDBITPhase.editingFinished.connect(self.setDBITPhase)

    def setDBITPhase(self):
        self.spinBoxDBITPhase.editingFinished.disconnect()
        try:
            self.det.dbitphase = self.spinBoxDBITPhase.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "DBit Phase Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxDBITPhase.editingFinished.connect(self.setDBITPhase)
        self.getDBITPhase()

    def getDBITPipeline(self):
        self.spinBoxDBITPipeline.editingFinished.disconnect()
        self.spinBoxDBITPipeline.setValue(self.det.dbitpipeline)
        self.spinBoxDBITPipeline.editingFinished.connect(self.setDBITPipeline)

    def setDBITPipeline(self):
        self.spinBoxDBITPipeline.editingFinished.disconnect()
        try:
            self.det.dbitpipeline = self.spinBoxDBITPipeline.value()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "DBit Pipeline Fail", str(e), QtWidgets.QMessageBox.Ok)
            pass
        #TODO: handling double event exceptions
        self.spinBoxDBITPipeline.editingFinished.connect(self.setDBITPipeline)
        self.getDBITPipeline()

    def getFileWrite(self):
        self.checkBoxFileWrite.stateChanged.disconnect()
        self.checkBoxFileWrite.setChecked(self.det.fwrite)
        self.checkBoxFileWrite.stateChanged.connect(self.setFileWrite)

    def setFileWrite(self):
        self.det.fwrite = self.checkBoxFileWrite.isChecked()
        self.getFileWrite()

    def getFileName(self):
        self.lineEditFileName.editingFinished.disconnect()
        self.lineEditFileName.setText(self.det.fname)
        self.lineEditFileName.editingFinished.connect(self.setFileName)

    def setFileName(self):
        self.det.fname = self.lineEditFileName.text()
        self.getFileName()

    def getFilePath(self):
        self.lineEditFilePath.editingFinished.disconnect()
        self.lineEditFilePath.setText(str(self.det.fpath))
        self.lineEditFilePath.editingFinished.connect(self.setFilePath)

    def setFilePath(self):
        self.det.fpath = Path(self.lineEditFilePath.text())
        self.getFilePath()

    def browseFilePath(self):
        response = QtWidgets.QFileDialog.getExistingDirectory(
            parent = self,
            caption = "Select Path to Save Output File",
            directory = os.getcwd(),
            options = (QtWidgets.QFileDialog.ShowDirsOnly | QtWidgets.QFileDialog.DontResolveSymlinks)
            # filter='README (*.md *.ui)'
        )
        if response:
            self.lineEditFilePath.setText(response)
            self.setFilePath()

    def getAccquisitionIndex(self):
        self.spinBoxAcquisitionIndex.editingFinished.disconnect()
        self.spinBoxAcquisitionIndex.setValue(self.det.findex)
        self.spinBoxAcquisitionIndex.editingFinished.connect(self.setAccquisitionIndex)

    def setAccquisitionIndex(self):
        self.det.findex = self.spinBoxAcquisitionIndex.value()
        self.getAccquisitionIndex()

    def getFrames(self):
        self.spinBoxFrames.editingFinished.disconnect()
        self.spinBoxFrames.setValue(self.det.frames)
        self.spinBoxFrames.editingFinished.connect(self.setFrames)

    def setFrames(self):
        self.det.frames = self.spinBoxFrames.value()
        self.getFrames()
    
    def getPeriod(self):
        self.spinBoxPeriod.editingFinished.disconnect()
        self.comboBoxPeriod.currentIndexChanged.disconnect()

        # Converting to right time unit for period
        tPeriod = self.det.period
        if tPeriod < 100e-9:
            self.comboBoxPeriod.setCurrentIndex(3)
            self.spinBoxPeriod.setValue(tPeriod / 1e-9)
        elif tPeriod < 100e-6:
            self.comboBoxPeriod.setCurrentIndex(2)
            self.spinBoxPeriod.setValue(tPeriod / 1e-6)
        elif tPeriod < 100e-3:
            self.comboBoxPeriod.setCurrentIndex(1)
            self.spinBoxPeriod.setValue(tPeriod / 1e-3)
        else:
            self.comboBoxPeriod.setCurrentIndex(0)
            self.spinBoxPeriod.setValue(tPeriod)

        self.spinBoxPeriod.editingFinished.connect(self.setPeriod)
        self.comboBoxPeriod.currentIndexChanged.connect(self.setPeriod)

    def setPeriod(self):
        if self.comboBoxPeriod.currentIndex() == 0:
            self.det.period = self.spinBoxPeriod.value()
        elif self.comboBoxPeriod.currentIndex() == 1:
            self.det.period = self.spinBoxPeriod.value() * (1e-3)
        elif self.comboBoxPeriod.currentIndex() == 2:
            self.det.period = self.spinBoxPeriod.value() * (1e-6)
        else:
            self.det.period = self.spinBoxPeriod.value() * (1e-9)

        self.getPeriod()

    def getTriggers(self):
        self.spinBoxTriggers.editingFinished.disconnect()
        self.spinBoxTriggers.setValue(self.det.triggers)
        self.spinBoxTriggers.editingFinished.connect(self.setTriggers)

    def setTriggers(self):
        self.det.triggers = self.spinBoxTriggers.value()
        self.getTriggers()

    def updateDetectorStatus(self, status):
        self.labelDetectorStatus.setText(status.name)

    def updateCurrentMeasurement(self):
        self.labelCurrentMeasurement.setText(str(self.currentMeasurement))
        #print(f"Meausrement {self.currentMeasurement}")
    
    def updateCurrentFrame(self, val):
        self.labelFrameNumber.setText(str(val))

    def updateAcquiredFrames(self, val):
        self.labelAcquiredFrames.setText(str(val))

    def toggleAcquire(self):
        if self.pushButtonStart.isChecked():
            self.showPatternViewer(False)
            self.acquire()
        else:
            self.stopAcquisition()

    def toggleStartButton(self, started):
        if started:
            self.pushButtonStart.setChecked(True)
            self.pushButtonStart.setText('Stop')
        else:        
            self.pushButtonStart.setChecked(False)
            self.pushButtonStart.setText('Start')

    def stopAcquisition(self):
        self.det.stop()
        self.stoppedFlag = True
        
    def checkBeforeAcquire(self):
        if self.radioButtonImage.isChecked():
            # matterhorn image
            if self.comboBoxPlot.currentText() == "Matterhorn":
                if self.romode not in [readoutMode.TRANSCEIVER_ONLY, readoutMode.DIGITAL_AND_TRANSCEIVER]:
                    QtWidgets.QMessageBox.warning(self, "Plot type", "To read Matterhorn image, please enable transceiver readout mode", QtWidgets.QMessageBox.Ok)
                    return False
                if self.transceiverTab.getTransceiverEnableReg() != Defines.Matterhorn.tranceiverEnable:
                    QtWidgets.QMessageBox.warning(self, "Plot type", "To read Matterhorn image, please set transceiver enable to " + str(Defines.Matterhorn.tranceiverEnable), QtWidgets.QMessageBox.Ok)
                    return False
            # moench04 image
            elif self.comboBoxPlot.currentText() == "Moench04":
                if self.romode not in [readoutMode.ANALOG_ONLY, readoutMode.ANALOG_AND_DIGITAL]:
                    QtWidgets.QMessageBox.warning(self, "Plot type", "To read Moench 04 image, please enable analog readout mode", QtWidgets.QMessageBox.Ok)
                    return False
                if self.nADCEnabled != 32:
                    QtWidgets.QMessageBox.warning(self, "Plot type", "To read Moench 04 image, please enable all 32 adcs", QtWidgets.QMessageBox.Ok)
                    return False
        return True


    def acquire(self):
        if not self.checkBeforeAcquire():
            self.toggleStartButton(False)
            return

        self.stoppedFlag = False
        self.toggleStartButton(True)
        self.currentMeasurement = 0

        # ensure zmq streaming is enabled
        if self.det.rx_zmqstream == 0:
            self.det.rx_zmqstream = 1

        # some functions that must be updated for local values
        self.getTransceiver()
        self.getAnalog()
        self.getDigital()
        self.getReadout()
        self.signalTab.getDBitOffset()
        self.adcTab.getADCEnableReg()
        self.signalTab.updateDigitalBitEnable()
        self.transceiverTab.getTransceiverEnableReg()

        self.startMeasurement()

    def startMeasurement(self):
        try:
            self.updateCurrentMeasurement()
            self.updateCurrentFrame(0)
            self.updateAcquiredFrames(0)
            self.progressBar.setValue(0)

            self.det.rx_start()
            self.det.start()
            time.sleep(Defines.Time_Wait_For_Packets_ms)
            self.checkEndofAcquisition()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Acquire Fail", str(e), QtWidgets.QMessageBox.Ok)
            self.checkEndofAcquisition()

    def checkEndofAcquisition(self):
        caught = self.det.rx_framescaught[0]
        self.updateAcquiredFrames(caught)
        status = self.det.getDetectorStatus()[0]
        self.updateDetectorStatus(status)
        measurementDone = False
        #print(f'status:{status}')
        match status:
            case runStatus.RUNNING:
                pass
            case runStatus.WAITING:
                pass
            case runStatus.TRANSMITTING:
                pass
            case _:
                measurementDone = True
        
        # check for 500ms for no packets
        # needs more time for 1g streaming out done
        if measurementDone:
            time.sleep(Defines.Time_Wait_For_Packets_ms)
            if self.det.rx_framescaught[0] != caught:
                measurementDone = False

        numMeasurments = self.spinBoxMeasurements.value()
        if measurementDone:
            if self.det.rx_status == runStatus.RUNNING:
                self.det.rx_stop()
            if self.checkBoxFileWrite.isChecked():
                self.spinBoxAcquisitionIndex.stepUp()
                self.setAccquisitionIndex()
            # next measurement
            self.currentMeasurement += 1
            if self.currentMeasurement < numMeasurments and not self.stoppedFlag:
                self.startMeasurement()
            else:
                self.statusTimer.stop()
                self.toggleStartButton(False)
        else:
            self.statusTimer.start(Defines.Time_Status_Refresh_ms)


    # For other functios
    #Reading data from zmq and decoding it
    def read_zmq(self):
        #print("in readzmq")
        try:
            msg = self.socket.recv_multipart(flags=zmq.NOBLOCK)
            if len(msg) != 2:
                if len(msg) != 1:
                    print(f'len(msg) = {len(msg)}')
                return
            header, data = msg
            jsonHeader = json.loads(header)
            #print(jsonHeader)
            self.progressBar.setValue(int(jsonHeader['progress']))
            self.updateCurrentFrame(jsonHeader['frameIndex'])
            #print(f"image size:{int(jsonHeader['size'])}")
            #print(f'Data size: {len(data)}')
                      
            # waveform
            if self.radioButtonWaveform.isChecked():
                # analog
                if self.romode.value in [0, 2]:
                    analog_array = np.array(np.frombuffer(data, dtype=np.uint16, count= self.nADCEnabled * self.asamples))
                    for i in range(32):
                        checkBox = getattr(self, f"checkBoxADC{i}Plot")
                        if checkBox.isChecked():
                            waveform = np.zeros(self.asamples)
                            for iSample in range(self.asamples):
                                # all adc for 1 sample together
                                waveform[iSample] = analog_array[iSample * self.nADCEnabled + i]
                            self.analogPlots[i].setData(waveform)

                # digital
                if self.romode.value in [1, 2, 4]:
                    dbitoffset = self.rx_dbitoffset
                    if self.romode.value == 2:
                        dbitoffset += self.nADCEnabled * 2 * self.asamples
                    digital_array = np.array(np.frombuffer(data, offset = dbitoffset, dtype=np.uint8))
                    nbitsPerDBit = self.dsamples
                    if nbitsPerDBit % 8 != 0:
                        nbitsPerDBit += (8 - (self.dsamples % 8))
                    offset = 0
                    irow = 0
                    for i in self.rx_dbitlist:
                        # where numbits * numsamples is not a multiple of 8
                        if offset % 8 != 0:
                            offset += (8 - (offset % 8))

                        checkBox = getattr(self, f"checkBoxBIT{i}Plot")
                        # bits enabled but not plotting
                        if not checkBox.isChecked():
                            offset += nbitsPerDBit
                            continue
                        # to plot
                        if checkBox.isChecked():
                            waveform = np.zeros(self.dsamples)
                            for iSample in range(self.dsamples):
                                # all samples for digital bit together from slsReceiver
                                index = (int)(offset / 8)
                                iBit = offset % 8
                                bit = (digital_array[index] >> iBit) & 1
                                waveform[iSample] = bit
                                offset += 1
                            self.digitalPlots[i].setData(waveform)
                            # TODO: left axis does not show 0 to 1, but keeps increasing
                            if self.radioButtonStripe.isChecked():
                                self.digitalPlots[i].setY(irow * 2)
                                irow += 1
                            else:
                                self.digitalPlots[i].setY(0)

                # transceiver
                if self.romode.value in [3, 4]:  
                    transceiverOffset = 0     
                    if self.romode.value == 4:
                        nbitsPerDBit = self.dsamples
                        if self.dsamples % 8 != 0:
                            nbitsPerDBit += (8 - (self.dsamples % 8))
                        transceiverOffset += self.nDbitEnabled * (nbitsPerDBit // 8)
                    #print(f'transceiverOffset:{transceiverOffset}')
                    trans_array = np.array(np.frombuffer(data, offset = transceiverOffset, dtype=np.uint16))
                    for i in range(4):
                        checkBox = getattr(self, f"checkBoxTransceiver{i}Plot")
                        if checkBox.isChecked():
                            waveform = np.zeros(self.tsamples * 4)
                            for iSample in range(self.tsamples * 4):
                                waveform[iSample] = trans_array[iSample * self.nTransceiverEnabled + i]
                            self.transceiverPlots[i].setData(waveform)
                        

            # image
            else:

                # analog
                if self.romode.value in [0, 2]:  
                    # get zoom state
                    viewBox = self.plotAnalogImage.getView()
                    state = viewBox.getState()

                    # get histogram (colorbar) levels and histogram zoom range
                    levels = self.plotAnalogImage.getHistogramWidget().item.getLevels()
                    histRange = self.plotAnalogImage.getHistogramWidget().item.getHistogramRange()


                    analog_array = np.array(np.frombuffer(data, dtype=np.uint16, count= self.nADCEnabled * self.asamples))
                    

                    try:
                        self.analog_frame = decoder.decode(analog_array, self.pixelMapAnalog)
                        self.plotAnalogImage.setImage(self.analog_frame.T)
                    except Exception as e:
                        self.statusbar.setStyleSheet("color:red")
                        message = f'Warning: Invalid size for Analog Image. Expected {self.nAnalogRows * self.nAnalogCols} size, got {analog_array.size} instead.'
                        self.updateCurrentFrame('Invalid Image')
                        self.statusbar.showMessage(message)
                        print(message)
                        pass

                    # keep the zoomed in state (not 1st image)
                    if self.firstAnalogImage:
                        self.firstAnalogImage = False
                    else:
                        viewBox.setState(state)
                        self.plotAnalogImage.getHistogramWidget().item.setLevels(min=levels[0],max=levels[1])
                        self.plotAnalogImage.getHistogramWidget().item.setHistogramRange(*histRange,padding=0)
                    
                    
                # transceiver
                if self.romode.value in [3, 4]:  
                    # get zoom state
                    viewBox = self.plotTransceiverImage.getView()
                    state = viewBox.getState()
                    # get histogram (colorbar) levels and histogram zoom range
                    levels = self.plotTransceiverImage.getHistogramWidget().item.getLevels()
                    histRange = self.plotTransceiverImage.getHistogramWidget().item.getHistogramRange()

                    transceiverOffset = 0     
                    if self.romode.value == 4:
                        nbitsPerDBit = self.dsamples
                        if self.dsamples % 8 != 0:
                            nbitsPerDBit += (8 - (self.dsamples % 8))
                        transceiverOffset += self.nDbitEnabled * (nbitsPerDBit // 8)
                    #print(f'transceiverOffset:{transceiverOffset}')
                    trans_array = np.array(np.frombuffer(data, offset = transceiverOffset, dtype=np.uint16))
                    
                    try:
                        self.transceiver_frame = decoder.decode(trans_array, self.pixelMapTransceiver)
                        # print(f"type of image:{type(self.transceiver_frame)}")
                        self.plotTransceiverImage.setImage(self.transceiver_frame)
                    except Exception as e:
                        self.statusbar.setStyleSheet("color:red")
                        message = f'Warning: Invalid size for Transceiver Image. Expected {self.nTransceiverRows * self.nTransceiverCols} size, got {trans_array.size} instead.'
                        self.updateCurrentFrame('Invalid Image')
                        self.statusbar.showMessage(message)
                        print(message)
                        pass

                    # keep the zoomed in state (not 1st image)
                    if self.firstTransceiverImage:
                        self.firstTransceiverImage = False
                    else:
                        viewBox.setState(state)
                        self.plotTransceiverImage.getHistogramWidget().item.setLevels(min=levels[0],max=levels[1])
                        self.plotTransceiverImage.getHistogramWidget().item.setHistogramRange(*histRange,padding=0)

        except zmq.ZMQError as e:
            pass
        except Exception as e:
            print(f'Caught exception: {str(e)}')

    def getRandomColor(self):
        '''
        Returns a random color range (except white) in format string eg. "#aabbcc"
        '''
        randomColor = random.randrange(0, 0xffffaa, 0xaa)
        return "#{:06x}".format(randomColor)

    def getActiveColor(self, button):
        return button.palette().color(QtGui.QPalette.Window)

    def setActiveColor(self, button, str_color):
        button.setStyleSheet(":enabled {background-color: %s" % str_color 
            + "} :disabled {background-color: grey}")

    def showPalette(self, button):
        color = QtWidgets.QColorDialog.getColor()
        if color.isValid():
            self.setActiveColor(button, color.name())
            # get the RGB Values
            #print(color.getRgb())

    def refresh_tab(self, tab_index):
        match tab_index:
            case 0:
                self.dacTab.refresh()
            case 1:
                self.powerSuppliesTab.refresh()
            case 2:
                self.slowADCsTab.refresh()
            case 3:
                self.transceiverTab.refresh()
            case 4:
                self.signalTab.refresh()
            case 5:
                self.adcTab.refresh()
            case 6:
                self.patternTab.refresh()
            case 7:
                self.refresh_tab_acquisition()
            case 8:
                self.refresh_tab_plot()
        
    def refresh_tab_acquisition(self):
        self.getReadout()
        self.getRunFrequency()
        self.getTransceiver()
        self.getAnalog()
        self.getDigital()
        self.getADCFrequency()
        self.getADCPhase()
        self.getADCPipeline()
        self.getDBITFrequency()
        self.getDBITPhase()
        self.getDBITPipeline()
        self.getFileWrite()
        self.getFileName()
        self.getFilePath()
        self.getAccquisitionIndex()
        self.getFrames()
        self.getTriggers()
        self.getPeriod()
        self.updateDetectorStatus(self.det.status)

    def refresh_tab_plot(self):
        self.getZMQHWM()

    def setup_zmq(self):
        self.det.rx_zmqstream = 1
        self.zmqIp = self.det.rx_zmqip
        self.zmqport = self.det.rx_zmqport
        self.zmq_stream = self.det.rx_zmqstream

        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.SUB)
        self.socket.connect(f"tcp://{self.zmqIp}:{self.zmqport}")
        self.socket.subscribe("")


    def setup_ui(self):
        #To check detector status
        self.statusTimer = QtCore.QTimer()
        self.statusTimer.timeout.connect(self.checkEndofAcquisition)

        #To auto trigger the read
        self.read_timer =  QtCore.QTimer()
        self.read_timer.timeout.connect(self.read_zmq)

        self.dacTab.setup_ui()
        self.powerSuppliesTab.setup_ui()
        self.signalTab.setup_ui()
        self.transceiverTab.setup_ui()
        self.adcTab.setup_ui()
        self.patternTab.setup_ui()

        # Acquisition Tab
        self.toggleStartButton(False)

        # pattern viewer plot area
        self.figure, self.ax = plt.subplots()
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.gridLayoutPatternViewer.addWidget(self.toolbar)
        self.gridLayoutPatternViewer.addWidget(self.canvas)
        self.figure.clear()

        # plot 
        self.initializeAllAnalogPlots()
        self.initializeAllDigitalPlots()
        self.initializeAllTransceiverPlots()
        self.initializeColorMaps()

    def keyPressEvent(self, event):
        if event.modifiers() & QtCore.Qt.ShiftModifier:
            if event.key() == QtCore.Qt.Key_Return:
                self.signalShortcutAcquire.emit()
        if event.modifiers() & QtCore.Qt.ControlModifier:
            if event.key() == QtCore.Qt.Key_Plus:
                self.signalShortcutTabUp.emit()
            if event.key() == QtCore.Qt.Key_Minus:
                self.signalShortcutTabDown.emit()
    
    def changeTabIndex(self, up):
        ind = self.tabWidget.currentIndex()
        if up:
            ind += 1
            if ind == Defines.Max_Tabs:
                ind = 0
        else:
            ind -= 1
            if ind == -1:
                ind = Defines.Max_Tabs -1
        self.tabWidget.setCurrentIndex(ind)

    def connect_ui(self):
        # Show info
        self.actionInfo.triggered.connect(self.showInfo)
        self.actionKeyboardShortcuts.triggered.connect(self.showKeyBoardShortcuts)
        self.actionLoadParameters.triggered.connect(self.loadParameters)

        self.dacTab.connect_ui()
        self.powerSuppliesTab.connect_ui()
        self.slowADCsTab.connect_ui()
        self.signalTab.connect_ui()
        self.transceiverTab.connect_ui()
        self.adcTab.connect_ui()
        self.patternTab.connect_ui()




        # For Acquistions Tab
        self.comboBoxROMode.currentIndexChanged.connect(self.setReadOut)
        self.spinBoxRunF.editingFinished.connect(self.setRunFrequency)
        self.spinBoxTransceiver.editingFinished.connect(self.setTransceiver)
        self.spinBoxAnalog.editingFinished.connect(self.setAnalog)
        self.spinBoxDigital.editingFinished.connect(self.setDigital)
        self.spinBoxADCF.editingFinished.connect(self.setADCFrequency)
        self.spinBoxADCPhase.editingFinished.connect(self.setADCPhase)
        self.spinBoxADCPipeline.editingFinished.connect(self.setADCPipeline)
        self.spinBoxDBITF.editingFinished.connect(self.setDBITFrequency)
        self.spinBoxDBITPhase.editingFinished.connect(self.setDBITPhase)
        self.spinBoxDBITPipeline.editingFinished.connect(self.setDBITPipeline)
        
        self.radioButtonNoPlot.clicked.connect(self.plotOptions)
        self.radioButtonWaveform.clicked.connect(self.plotOptions)
        self.radioButtonDistribution.clicked.connect(self.plotOptions)
        self.radioButtonImage.clicked.connect(self.plotOptions)
        self.comboBoxPlot.currentIndexChanged.connect(self.setPixelMap)
        self.comboBoxColorMap.currentIndexChanged.connect(self.setColorMap)
        self.comboBoxZMQHWM.currentIndexChanged.connect(self.setZMQHWM)
        self.spinBoxSerialOffset.editingFinished.connect(self.setSerialOffset)
        self.spinBoxNCount.editingFinished.connect(self.setNCounter)
        self.spinBoxDynamicRange.editingFinished.connect(self.setDynamicRange)
        self.spinBoxImageX.editingFinished.connect(self.setImageX)
        self.spinBoxImageY.editingFinished.connect(self.setImageY)
        self.checkBoxAcquire.stateChanged.connect(self.setPedestal)
        self.checkBoxSubtract.stateChanged.connect(self.setPedestal)
        self.checkBoxCommonMode.stateChanged.connect(self.setPedestal)
        self.pushButtonReset.clicked.connect(self.resetPedestal)
        self.checkBoxRaw.stateChanged.connect(self.setRawData)
        self.spinBoxRawMin.editingFinished.connect(self.setRawData)
        self.spinBoxRawMax.editingFinished.connect(self.setRawData)
        self.checkBoxPedestal.stateChanged.connect(self.setPedestalSubtract)
        self.spinBoxPedestalMin.editingFinished.connect(self.setPedestalSubtract)
        self.spinBoxPedestalMax.editingFinished.connect(self.setPedestalSubtract)
        self.spinBoxFit.editingFinished.connect(self.setFitADC)
        self.spinBoxPlot.editingFinished.connect(self.setPlotBit)
        self.pushButtonReferesh.clicked.connect(self.plotReferesh)

        self.checkBoxFileWrite.stateChanged.connect(self.setFileWrite)
        self.lineEditFileName.editingFinished.connect(self.setFileName)
        self.lineEditFilePath.editingFinished.connect(self.setFilePath)
        self.pushButtonFilePath.clicked.connect(self.browseFilePath)
        self.spinBoxAcquisitionIndex.editingFinished.connect(self.setAccquisitionIndex)
        self.spinBoxFrames.editingFinished.connect(self.setFrames)
        self.spinBoxPeriod.editingFinished.connect(self.setPeriod)
        self.comboBoxPeriod.currentIndexChanged.connect(self.setPeriod)
        self.spinBoxTriggers.editingFinished.connect(self.setTriggers)
        self.pushButtonStart.clicked.connect(self.toggleAcquire)

        # plot
        self.plotAnalogImage.scene.sigMouseMoved.connect(partial(self.showPlotValues, self.plotAnalogImage))
        self.plotDigitalImage.scene.sigMouseMoved.connect(partial(self.showPlotValues, self.plotDigitalImage))
        self.plotTransceiverImage.scene.sigMouseMoved.connect(partial(self.showPlotValues, self.plotTransceiverImage))
        
    def showPlotValues(self, sender, pos):
        x = sender.getImageItem().mapFromScene(pos).x()
        y = sender.getImageItem().mapFromScene(pos).y()
        val = 0
        nMaxY = self.nAnalogRows
        nMaxX = self.nAnalogCols
        frame = self.analog_frame
        if sender == self.plotDigitalImage:
            nMaxY = self.nDigitalRows
            nMaxX = self.nDigitalCols    
            frame = self.digital_frame
        elif sender == self.plotTransceiverImage:
            nMaxY = self.nTransceiverRows
            nMaxX = self.nTransceiverCols          
            frame = self.transceiver_frame
        if x >= 0 and x < nMaxX and y >= 0 and y < nMaxY:
            val = frame[int(x), int(y)]
            message = f'[{x:.2f}, {y:.2f}] = {val:.2f}'
            sender.setToolTip(message)
            #print(message)
        else:
            sender.setToolTip('')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    main = MainWindow()
    main.show()
    # Run the app
    app.exec_()
